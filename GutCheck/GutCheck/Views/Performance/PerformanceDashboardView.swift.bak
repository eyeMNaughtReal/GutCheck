import SwiftUI
import Charts

/// Performance dashboard view for monitoring app performance in real-time
struct PerformanceDashboardView: View {
    @StateObject private var performanceProfiler = PerformanceProfiler.shared
    @State private var selectedTimeRange: TimeRange = .lastHour
    @State private var showingExportSheet = false
    @State private var showingSettings = false
    
    enum TimeRange: String, CaseIterable, Identifiable {
        case lastHour = "Last Hour"
        case lastDay = "Last Day"
        case lastWeek = "Last Week"
        case lastMonth = "Last Month"
        
        var id: String { rawValue }
        
        var hours: Int {
            switch self {
            case .lastHour: return 1
            case .lastDay: return 24
            case .lastWeek: return 168
            case .lastMonth: return 720
            }
        }
    }
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Header
                    headerSection
                    
                    // Time range selector
                    timeRangeSelector
                    
                    // Current metrics
                    currentMetricsSection
                    
                    // Memory usage chart
                    memoryUsageSection
                    
                    // Performance history
                    performanceHistorySection
                    
                    // Recommendations
                    recommendationsSection
                }
                .padding()
            }
            .navigationTitle("Performance Monitor")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button("Export Data") {
                            showingExportSheet = true
                        }
                        Button("Settings") {
                            showingSettings = true
                        }
                        Button("Clear History") {
                            performanceProfiler.clearHistory()
                        }
                    } label: {
                        Image(systemName: "ellipsis.circle")
                    }
                }
            }
            .refreshable {
                // Refresh is automatic via PerformanceProfiler timer
            }
            .sheet(isPresented: $showingExportSheet) {
                ExportPerformanceDataView()
            }
            .sheet(isPresented: $showingSettings) {
                PerformanceSettingsView()
            }
        }
    }
    
    // MARK: - Header Section
    
    private var headerSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Real-time Performance Monitoring")
                .font(.title2)
                .fontWeight(.semibold)
            
            Text("Monitor memory usage, operation performance, and system health in real-time.")
                .font(.subheadline)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    
    // MARK: - Time Range Selector
    
    private var timeRangeSelector: some View {
        Picker("Time Range", selection: $selectedTimeRange) {
            ForEach(TimeRange.allCases) { timeRange in
                Text(timeRange.rawValue).tag(timeRange)
            }
        }
        .pickerStyle(.segmented)
    }
    
    // MARK: - Current Metrics Section
    
    private var currentMetricsSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Current Status")
                .font(.title3.bold())
                .foregroundColor(ColorTheme.primaryText)
            
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 16) {
                MetricCard(
                    title: "Memory Usage",
                    value: formatBytes(performanceProfiler.currentMetrics.memoryUsage.usedMemory),
                    subtitle: performanceProfiler.currentMetrics.memoryUsage.memoryPressure.description,
                    color: memoryPressureColor,
                    icon: "memorychip"
                )
                
                MetricCard(
                    title: "Active Operations",
                    value: "\(performanceProfiler.currentMetrics.activeOperations)",
                    subtitle: "Concurrent",
                    color: operationsColor,
                    icon: "gear"
                )
                
                MetricCard(
                    title: "Battery Level",
                    value: "\(Int(performanceProfiler.currentMetrics.batteryLevel * 100))%",
                    subtitle: "Remaining",
                    color: batteryColor,
                    icon: "battery.100"
                )
                
                MetricCard(
                    title: "Last Update",
                    value: performanceProfiler.currentMetrics.lastUpdateTime.formatted(.relative(presentation: .named)),
                    subtitle: "Status",
                    color: .blue,
                    icon: "clock"
                )
            }
        }
    }
    
    // MARK: - Memory Usage Section
    
    private var memoryUsageSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Memory Usage Trend")
                .font(.title3.bold())
                .foregroundColor(ColorTheme.primaryText)
            
            if performanceProfiler.performanceHistory.isEmpty {
                Text("No data available yet")
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, minHeight: 200)
                    .background(ColorTheme.surface)
                    .cornerRadius(12)
            } else {
                Chart {
                    ForEach(filteredHistory) { snapshot in
                        LineMark(
                            x: .value("Time", snapshot.timestamp),
                            y: .value("Memory", snapshot.metrics.memoryUsage.usedMemory / (1024 * 1024))
                        )
                        .foregroundStyle(memoryPressureColor)
                        .lineStyle(StrokeStyle(lineWidth: 2))
                        
                        AreaMark(
                            x: .value("Time", snapshot.timestamp),
                            y: .value("Memory", snapshot.metrics.memoryUsage.usedMemory / (1024 * 1024))
                        )
                        .foregroundStyle(memoryPressureColor.opacity(0.1))
                    }
                }
                .frame(height: 200)
                .chartYAxis {
                    AxisMarks(position: .leading) { value in
                        AxisValueLabel {
                            if let doubleValue = value.as(Double.self) {
                                Text("\(Int(doubleValue)) MB")
                            }
                        }
                    }
                }
                .chartXAxis {
                    AxisMarks { value in
                        AxisValueLabel {
                            if let date = value.as(Date.self) {
                                Text(date.formatted(.dateTime.hour().minute()))
                            }
                        }
                    }
                }
            }
        }
    }
    
    // MARK: - Performance History Section
    
    private var performanceHistorySection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Performance History")
                .font(.title3.bold())
                .foregroundColor(ColorTheme.primaryText)
            
            if performanceProfiler.performanceHistory.isEmpty {
                Text("No performance data recorded yet")
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, minHeight: 100)
                    .background(ColorTheme.surface)
                    .cornerRadius(12)
            } else {
                LazyVStack(spacing: 12) {
                    ForEach(filteredHistory.prefix(10)) { snapshot in
                        PerformanceHistoryRow(snapshot: snapshot)
                    }
                }
            }
        }
    }
    
    // MARK: - Recommendations Section
    
    private var recommendationsSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Recommendations")
                .font(.title3.bold())
                .foregroundColor(ColorTheme.primaryText)
            
            let recommendations = performanceProfiler.generateRecommendations()
            
            if recommendations.isEmpty {
                Text("All systems operating normally")
                    .foregroundColor(.green)
                    .frame(maxWidth: .infinity, minHeight: 60)
                    .background(ColorTheme.surface)
                    .cornerRadius(12)
            } else {
                VStack(alignment: .leading, spacing: 12) {
                    ForEach(recommendations, id: \.self) { recommendation in
                        HStack(alignment: .top, spacing: 12) {
                            Image(systemName: "exclamationmark.triangle.fill")
                                .foregroundColor(.orange)
                                .frame(width: 20)
                            
                            Text(recommendation)
                                .font(.body)
                                .foregroundColor(ColorTheme.primaryText)
                            
                            Spacer()
                        }
                        .padding()
                        .background(ColorTheme.surface)
                        .cornerRadius(8)
                    }
                }
            }
        }
    }
    
    // MARK: - Computed Properties
    
    private var filteredHistory: [PerformanceProfiler.PerformanceSnapshot] {
        let cutoffDate = Date().addingTimeInterval(-TimeInterval(selectedTimeRange.hours * 3600))
        return performanceProfiler.performanceHistory.filter { $0.timestamp >= cutoffDate }
    }
    
    private var memoryPressureColor: Color {
        switch performanceProfiler.currentMetrics.memoryUsage.memoryPressure {
        case .normal:
            return .green
        case .warning:
            return .orange
        case .critical:
            return .red
        }
    }
    
    private var operationsColor: Color {
        let operations = performanceProfiler.currentMetrics.activeOperations
        if operations > performanceProfiler.criticalThresholds.maxConcurrentOperations {
            return .red
        } else if operations > performanceProfiler.criticalThresholds.maxConcurrentOperations / 2 {
            return .orange
        } else {
            return .green
        }
    }
    
    private var batteryColor: Color {
        let battery = performanceProfiler.currentMetrics.batteryLevel
        if battery < 0.2 {
            return .red
        } else if battery < 0.5 {
            return .orange
        } else {
            return .green
        }
    }
    
    // MARK: - Helper Methods
    
    private func formatBytes(_ bytes: UInt64) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useMB, .useGB]
        formatter.countStyle = .memory
        return formatter.string(fromByteCount: Int64(bytes))
    }
}

// MARK: - Supporting Views

struct StatusIndicator: View {
    let status: String
    let color: Color
    
    var body: some View {
        HStack(spacing: 6) {
            Circle()
                .fill(color)
                .frame(width: 8, height: 8)
            
            Text(status)
                .font(.caption)
                .foregroundColor(color)
        }
    }
}

struct MetricCard: View {
    let title: String
    let value: String
    let subtitle: String
    let color: Color
    let icon: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: icon)
                    .foregroundColor(color)
                    .font(.title2)
                
                Spacer()
                
                StatusIndicator(status: subtitle, color: color)
            }
            
            Text(value)
                .font(.title2.bold())
                .foregroundColor(ColorTheme.primaryText)
            
            Text(title)
                .font(.caption)
                .foregroundColor(ColorTheme.secondaryText)
        }
        .padding()
        .background(ColorTheme.surface)
        .cornerRadius(12)
    }
}

struct PerformanceHistoryRow: View {
    let snapshot: PerformanceProfiler.PerformanceSnapshot
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(snapshot.context)
                    .font(.headline)
                    .foregroundColor(ColorTheme.primaryText)
                
                Spacer()
                
                Text(snapshot.timestamp.formatted(.relative(presentation: .named)))
                    .font(.caption)
                    .foregroundColor(ColorTheme.secondaryText)
            }
            
            if !snapshot.recommendations.isEmpty {
                Text(snapshot.recommendations.first ?? "")
                    .font(.body)
                    .foregroundColor(ColorTheme.secondaryText)
                    .lineLimit(2)
            }
            
            HStack {
                Label("\(formatBytes(snapshot.metrics.memoryUsage.usedMemory))", systemImage: "memorychip")
                Spacer()
                Label("\(snapshot.metrics.activeOperations) ops", systemImage: "gear")
            }
            .font(.caption)
            .foregroundColor(ColorTheme.secondaryText)
        }
        .padding()
        .background(ColorTheme.surface)
        .cornerRadius(8)
    }
    
    private func formatBytes(_ bytes: UInt64) -> String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useMB]
        formatter.countStyle = .memory
        return formatter.string(fromByteCount: Int64(bytes))
    }
}

struct ExportPerformanceDataView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var performanceProfiler = PerformanceProfiler.shared
    @State private var showingShareSheet = false
    @State private var exportData: Data?
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Image(systemName: "square.and.arrow.up")
                    .font(.system(size: 48))
                    .foregroundColor(.blue)
                
                Text("Export Performance Data")
                    .font(.title2.bold())
                
                Text("Export your performance data for analysis or sharing with developers.")
                    .font(.body)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                
                Button("Generate Export") {
                    exportData = performanceProfiler.exportPerformanceData()
                    if exportData != nil {
                        showingShareSheet = true
                    }
                }
                .buttonStyle(.borderedProminent)
                
                Spacer()
            }
            .padding()
            .navigationTitle("Export Data")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .sheet(isPresented: $showingShareSheet) {
                if let data = exportData {
                    // Use the existing ShareSheet from HealthcareExportView
                    ShareSheet(activityItems: [data])
                }
            }
        }
    }
}

struct PerformanceSettingsView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var performanceProfiler = PerformanceProfiler.shared
    @State private var maxMemoryUsage: Double = 500
    @State private var maxOperationDuration: Double = 5.0
    @State private var maxConcurrentOperations: Double = 10
    
    var body: some View {
        NavigationView {
            Form {
                Section("Memory Thresholds") {
                    VStack(alignment: .leading) {
                        Text("Max Memory Usage: \(Int(maxMemoryUsage)) MB")
                        Slider(value: $maxMemoryUsage, in: 100...1000, step: 50)
                    }
                    
                    VStack(alignment: .leading) {
                        Text("Memory Warning Threshold: \(Int(maxMemoryUsage * 0.8)) MB")
                        Text("Automatically set to 80% of max")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                Section("Operation Thresholds") {
                    VStack(alignment: .leading) {
                        Text("Max Operation Duration: \(String(format: "%.1f", maxOperationDuration))s")
                        Slider(value: $maxOperationDuration, in: 1...10, step: 0.5)
                    }
                    
                    VStack(alignment: .leading) {
                        Text("Max Concurrent Operations: \(Int(maxConcurrentOperations))")
                        Slider(value: $maxConcurrentOperations, in: 5...20, step: 1)
                    }
                }
                
                Section("Profiling") {
                    Toggle("Enable Profiling", isOn: $performanceProfiler.isProfilingEnabled)
                    
                    Button("Clear History") {
                        performanceProfiler.clearHistory()
                    }
                    .foregroundColor(.red)
                }
            }
            .navigationTitle("Performance Settings")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        updateThresholds()
                        dismiss()
                    }
                }
            }
            .onAppear {
                loadCurrentThresholds()
            }
        }
    }
    
    private func loadCurrentThresholds() {
        maxMemoryUsage = Double(performanceProfiler.criticalThresholds.maxMemoryUsage / (1024 * 1024))
        maxOperationDuration = performanceProfiler.criticalThresholds.maxOperationDuration
        maxConcurrentOperations = Double(performanceProfiler.criticalThresholds.maxConcurrentOperations)
    }
    
    private func updateThresholds() {
        performanceProfiler.criticalThresholds.maxMemoryUsage = UInt64(maxMemoryUsage * 1024 * 1024)
        performanceProfiler.criticalThresholds.maxOperationDuration = maxOperationDuration
        performanceProfiler.criticalThresholds.maxConcurrentOperations = Int(maxConcurrentOperations)
        performanceProfiler.criticalThresholds.memoryWarningThreshold = UInt64(maxMemoryUsage * 0.8 * 1024 * 1024)
    }
}
